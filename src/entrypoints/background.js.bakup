// @ts-nocheck
import 'webextension-polyfill'
import { browser } from 'wxt/browser'
import {
  loadSettings,
  subscribeToSettingsChanges,
} from '../stores/settingsStore.svelte.js'
import {
  summaryState,
  summarizeSelectedText,
  logAllGeneratedSummariesToHistory,
} from '../stores/summaryStore.svelte.js'
import { get } from 'svelte/store'
import {
  addHistory,
  addSummary,
  updateHistoryArchivedStatus,
} from '@/lib/db/indexedDBService.js'
import { getAISDKModel, mapGenerationConfig } from '@/lib/api/aiSdkAdapter.js'
import { generateText } from 'ai'

// --- Service Classes ---

class OllamaCorsService {
  constructor() {
    this.ruleId = 1001
    this.initialized = false
  }

  async setupOllamaCorsRules(endpoint = 'http://127.0.0.1:11434') {
    try {
      const normalizedEndpoint = endpoint.endsWith('/')
        ? endpoint.slice(0, -1)
        : endpoint
      const url = new URL(normalizedEndpoint)
      const requestRule = {
        id: this.ruleId,
        priority: 1,
        condition: {
          urlFilter: `${normalizedEndpoint}/*`,
          resourceTypes: ['xmlhttprequest'],
        },
        action: {
          type: 'modifyHeaders',
          requestHeaders: [
            {
              header: 'origin',
              operation: 'set',
              value: normalizedEndpoint,
            },
          ],
        },
      }
      const responseRule = {
        id: this.ruleId + 1,
        priority: 1,
        condition: {
          urlFilter: `${normalizedEndpoint}/*`,
          resourceTypes: ['xmlhttprequest'],
        },
        action: {
          type: 'modifyHeaders',
          responseHeaders: [
            {
              header: 'Access-Control-Allow-Origin',
              operation: 'set',
              value: '*',
            },
            {
              header: 'Access-Control-Allow-Methods',
              operation: 'set',
              value: 'GET, POST, PUT, DELETE, OPTIONS',
            },
            {
              header: 'Access-Control-Allow-Headers',
              operation: 'set',
              value: 'Content-Type, Authorization',
            },
          ],
        },
      }
      await browser.declarativeNetRequest.updateDynamicRules({
        removeRuleIds: [this.ruleId, this.ruleId + 1],
        addRules: [requestRule, responseRule],
      })
      this.initialized = true
      console.log(
        '[OllamaCorsService] CORS bypass rules setup successfully for:',
        normalizedEndpoint
      )
      return true
    } catch (error) {
      console.error('[OllamaCorsService] Failed to setup CORS rules:', error)
      return false
    }
  }

  async updateEndpoint(newEndpoint) {
    if (!newEndpoint) return false
    return this.setupOllamaCorsRules(newEndpoint)
  }
}

class OllamaApiProxyService {
  async handleApiRequest(providerId, settings, systemInstruction, userPrompt) {
    try {
      console.log(
        `[OllamaApiProxy] Handling API request for provider: ${providerId}`
      )
      const baseModel = getAISDKModel(providerId, settings)
      const generationConfig = mapGenerationConfig(settings)
      const { text } = await generateText({
        model: baseModel,
        system: systemInstruction,
        prompt: userPrompt,
        ...generationConfig,
      })
      console.log(`[OllamaApiProxy] API request completed successfully`)
      return text
    } catch (error) {
      console.error(`[OllamaApiProxy] API request failed:`, error)
      throw error
    }
  }
}

// --- Main Background Logic ---

export default defineBackground(() => {
  const ollamaCorsService = new OllamaCorsService()
  const ollamaApiProxy = new OllamaApiProxyService()
  let sidePanelPort = null
  let pendingSelectedText = null

  // --- Initial Setup ---
  loadSettings()
  subscribeToSettingsChanges(async (newSettings) => {
    if (newSettings.selectedProvider === 'ollama') {
      console.log(
        '[Background] Ollama selected, ensuring CORS rules are active.'
      )
      await ollamaCorsService.setupOllamaCorsRules(
        newSettings.ollamaEndpoint || 'http://127.0.0.1:11434'
      )
    }
  })
  ;(async () => {
    try {
      const settings = await loadSettings()
      if (settings.selectedProvider === 'ollama') {
        const endpoint = settings.ollamaEndpoint || 'http://127.0.0.1:11434'
        await ollamaCorsService.setupOllamaCorsRules(endpoint)
      }
    } catch (error) {
      console.error(
        '[Background] Failed to initialize Ollama CORS service:',
        error
      )
    }
  })()

  // --- Consolidated Message Listener ---
  browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log(`[Background] Received message:`, message)

    // --- Ollama API Proxy (Async) ---
    if (message.type === 'OLLAMA_API_REQUEST') {
      ;(async () => {
        const {
          providerId,
          settings,
          systemInstruction,
          userPrompt,
          requestId,
        } = message
        console.log(`[Background] Handling OLLAMA_API_REQUEST ${requestId}`)
        try {
          const result = await ollamaApiProxy.handleApiRequest(
            providerId,
            settings,
            systemInstruction,
            userPrompt
          )
          sendResponse({
            type: 'OLLAMA_API_RESPONSE',
            requestId,
            success: true,
            result,
          })
        } catch (error) {
          console.error('[Background] Ollama API proxy error:', error)
          sendResponse({
            type: 'OLLAMA_API_ERROR',
            requestId: message.requestId,
            success: false,
            error: {
              message: error.message,
              type: error.type || 'PROXY_ERROR',
            },
          })
        }
      })()
      return true // Keep channel open for async response
    }

    // --- Other Async Handlers ---
    if (message.type === 'SAVE_TO_HISTORY') {
      ;(async () => {
        try {
          const result = await addHistory(message.payload.historyData)
          sendResponse({ success: true, id: String(result) })
        } catch (error) {
          sendResponse({ success: false, error: error.message })
        }
      })()
      return true
    }

    if (message.type === 'SAVE_TO_ARCHIVE') {
      ;(async () => {
        try {
          const newArchiveId = await addSummary(message.payload.archiveEntry)
          if (message.payload.historySourceId) {
            await updateHistoryArchivedStatus(
              message.payload.historySourceId,
              true
            )
          }
          sendResponse({ success: true, newArchiveId: String(newArchiveId) })
        } catch (error) {
          sendResponse({ success: false, error: error.message })
        }
      })()
      return true
    }

    if (message.action === 'getTranscript' && message.tabId) {
      ;(async () => {
        try {
          const response = await browser.tabs.sendMessage(message.tabId, {
            action: 'fetchTranscript',
            lang: message.lang,
          })
          sendResponse(
            response && response.success
              ? { transcript: response.transcript }
              : { error: response?.error || 'Failed to get transcript.' }
          )
        } catch (err) {
          sendResponse({ success: false, error: err.message })
        }
      })()
      return true
    }

    if (message.action === 'REQUEST_SUMMARY') {
      ;(async () => {
        const { type, payload, requestId } = message
        try {
          if (type === 'selectedText') {
            const selectedText = payload.text
            if (!selectedText) throw new Error('No text selected.')
            await summarizeSelectedText(selectedText)
            const summary = get(summaryState.selectedTextSummary)
            sendResponse({ action: 'SUMMARY_RESPONSE', summary, requestId })
          } else {
            throw new Error(`Unsupported summary type: ${type}`)
          }
        } catch (error) {
          sendResponse({
            action: 'SUMMARY_ERROR',
            error: error.message,
            requestId,
          })
        }
      })()
      return true
    }

    // --- Synchronous Handlers ---
    if (message.type === 'OPEN_ARCHIVE') {
      browser.tabs.create({
        url: browser.runtime.getURL('archive.html'),
        active: true,
      })
    } else if (message.type === 'OPEN_SETTINGS') {
      browser.tabs.create({
        url: browser.runtime.getURL('settings.html'),
        active: true,
      })
    } else if (message.type === 'UPDATE_OLLAMA_ENDPOINT') {
      ollamaCorsService.updateEndpoint(message.endpoint)
    } else if (message.action === 'courseContentFetched') {
      if (sidePanelPort) {
        sidePanelPort.postMessage({
          action: 'courseContentAvailable',
          content: message.content,
          lang: message.lang,
          courseType: message.courseType,
        })
      }
    } else if (message.action === 'requestCurrentTabInfo') {
      ;(async () => {
        try {
          const [activeTab] = await browser.tabs.query({
            active: true,
            currentWindow: true,
          })
          if (!activeTab) return
          const YOUTUBE_REGEX = /youtube\.com\/watch/i
          const UDEMY_REGEX = /udemy\.com\/course\/.*\/learn\//i
          const COURSERA_REGEX = /coursera\.org\/learn\//i
          const info = {
            action: 'currentTabInfo',
            tabId: activeTab.id,
            tabUrl: activeTab.url,
            tabTitle: activeTab.title,
            isYouTube: YOUTUBE_REGEX.test(activeTab.url),
            isUdemy: UDEMY_REGEX.test(activeTab.url),
            isCoursera: COURSERA_REGEX.test(activeTab.url),
          }
          if (sidePanelPort) sidePanelPort.postMessage(info)
          else browser.runtime.sendMessage(info).catch(() => {})
        } catch (e) {
          console.error('Error getting current tab info:', e)
        }
      })()
    }

    // Return false for sync messages or if no handler matched
    return false
  })

  // --- Other Background Logic (Connections, Commands, etc.) ---
  browser.runtime.onConnect.addListener((port) => {
    if (port.name === 'side-panel') {
      sidePanelPort = port
      port.onDisconnect.addListener(() => {
        sidePanelPort = null
      })
    }
  })

  // ... (Keep other listeners like onCommand, onInstalled, onUpdated as they are)
})
