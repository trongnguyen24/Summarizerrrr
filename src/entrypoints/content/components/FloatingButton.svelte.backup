<script>
  // @ts-nocheck
  import Logdev from '@/components/settings/Logdev.svelte'
  import {
    settings,
    loadSettings,
    updateSettings,
    subscribeToSettingsChanges,
  } from '@/stores/settingsStore.svelte.js'
  import {
    loadThemeSettings,
    subscribeToThemeChanges,
  } from '@/stores/themeStore.svelte.js'
  import { createDraggable, utils } from 'animejs' // Import animejs

  let { toggle, topButton } = $props()
  let buttonElement
  let snapedge
  let buttonElementBG
  let floatingButtonElement // Thêm biến này để tham chiếu đến nút floating-button
  let draggableInstance = null // Khởi tạo draggableInstance
  let releaseTimeout = null // Để lưu trữ timeout ID

  // Initialize stores
  $effect(() => {
    loadSettings()
    subscribeToSettingsChanges()
  })

  let startX, startY, isDragging

  const DRAG_THRESHOLD = 10 // pixels

  /**
   * Gets the current window width for dynamic snap points.
   * @returns {number} The current window width in pixels
   */
  function getWindowWidth() {
    return document.body.clientWidth
  }

  /**
   * Initializes draggable with onResize callback.
   */
  function initializeDraggable() {
    if (!buttonElement) return

    const draggables = createDraggable(buttonElement, {
      container: snapedge,
      x: { snap: [0, getWindowWidth()] },

      cursor: {
        onHover: 'pointer',
        onGrab: 'grabbing',
      },
      onGrab: () => {},
      onResize: (self) => {},
      onRelease: (self) => {
        // Xóa timeout cũ nếu có
        if (releaseTimeout) {
          clearTimeout(releaseTimeout)
        }
        // Đặt timeout mới để lấy giá trị top sau 500ms
        releaseTimeout = setTimeout(() => {
          if (
            buttonElement.getBoundingClientRect().left >
            getWindowWidth() / 2
          ) {
            updateSettings({ floatButtonLeft: false })
          } else {
            updateSettings({ floatButtonLeft: true })
          }
          const currentTop = buttonElement.getBoundingClientRect().top
          updateSettings({ floatButton: currentTop })

          console.log('Floating button top after 500ms:', currentTop)
        }, 800)
      },
    })
    if (settings.floatButtonLeft === false) {
      draggables.setX(getWindowWidth() - 40)
      buttonElementBG.classList.remove('round-l')
      buttonElementBG.classList.add('round-r')
    } else {
      buttonElementBG.classList.remove('round-r')
      buttonElementBG.classList.add('round-l')
    }
  }

  /**
   * Cleanup function to prevent memory leaks.
   */
  function destroyDraggable() {
    if (draggableInstance) {
      draggableInstance.destroy()
    }
  }

  $effect(() => {
    if (buttonElement) {
      initializeDraggable()

      function handleStart(e) {
        // e.preventDefault() // Let's not prevent default on start, might interfere with other things
        isDragging = false
        const touch = e.type === 'touchstart' ? e.touches[0] : e
        startX = touch.clientX
        startY = touch.clientY
        window.addEventListener('mousemove', handleMove, { passive: false })
        window.addEventListener('touchmove', handleMove, { passive: false })
        window.addEventListener('mouseup', handleEnd)
        window.addEventListener('touchend', handleEnd)
      }

      function handleMove(e) {
        // e.preventDefault() // Prevent scroll while dragging
        const touch = e.type === 'touchmove' ? e.touches[0] : e
        const deltaX = Math.abs(touch.clientX - startX)
        const deltaY = Math.abs(touch.clientY - startY)
        if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
          isDragging = true
          buttonElementBG.classList.remove('round-l')
          buttonElementBG.classList.remove('round-r')
        }
      }

      function handleEnd(e) {
        // This is the key fix: prevent the browser from firing a "ghost" click event
        // after a touchend event.
        if (e.type === 'touchend') {
          e.preventDefault()
        }

        if (!isDragging) {
          toggle?.()
        }

        // Cleanup listeners
        window.removeEventListener('mousemove', handleMove)
        window.removeEventListener('touchmove', handleMove)
        window.removeEventListener('mouseup', handleEnd)
        window.removeEventListener('touchend', handleEnd)
      }

      buttonElement.addEventListener('mousedown', handleStart)
      buttonElement.addEventListener('touchstart', handleStart, {
        passive: true,
      })

      return () => {
        destroyDraggable()
        buttonElement.removeEventListener('mousedown', handleStart)
        buttonElement.removeEventListener('touchstart', handleStart)
        window.removeEventListener('mousemove', handleMove)
        window.removeEventListener('touchmove', handleMove)
        window.removeEventListener('mouseup', handleEnd)
        window.removeEventListener('touchend', handleEnd)
      }
    }
  })
</script>

<!-- svelte-ignore a11y_consider_explicit_label -->
<button
  bind:this={buttonElement}
  class="floating-button round-l round-r"
  title="Toggle Summarizer"
  style="top: {topButton}px;"
>
  <div bind:this={buttonElementBG} class="floating-button-bg">
    <div class="BG-cri">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="18"
        height="18"
        viewBox="0 0 16 16"
      >
        <path
          fill="currentColor"
          d="M7.53 1.282a.5.5 0 0 1 .94 0l.478 1.306a7.5 7.5 0 0 0 4.464 4.464l1.305.478a.5.5 0 0 1 0 .94l-1.305.478a7.5 7.5 0 0 0-4.464 4.464l-.478 1.305a.5.5 0 0 1-.94 0l-.478-1.305a7.5 7.5 0 0 0-4.464-4.464L1.282 8.47a.5.5 0 0 1 0-.94l1.306-.478a7.5 7.5 0 0 0 4.464-4.464Z"
        />
      </svg>
    </div>
  </div>
</button>

<div bind:this={snapedge} class="snapedge"></div>

<style>
  .floating-button {
    position: fixed;
    background: none !important;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none !important;
    display: flex;
    padding: 0 !important;
    align-items: center;
    justify-content: center;
    z-index: 10000000000000000000000000;
    left: 0;
  }

  .snapedge {
    position: fixed;
    right: 0;
    bottom: 0;
    top: 0;
    left: 0;
    overflow: hidden;
    pointer-events: none;
    z-index: 100000;
  }

  .floating-button:hover ~ .snapedge {
    pointer-events: visible;
  }

  .floating-button-bg {
    border-radius: 50px;
    background: #94a3c53c;
    width: 40px;
    height: 40px;
    color: rgb(167, 167, 167);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease-in-out;
  }
  .round-l {
    border-radius: 0 50px 50px 0 !important;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }
  .round-r {
    border-radius: 50px 0 0 50px !important;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }
  .floating-button-bg:hover {
    background: #ff8711;
    color: rgb(119, 196, 255);
  }
  .BG-cri {
    background: #00000000;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease-in-out;
  }
  .floating-button-bg:hover .BG-cri {
    background: #25345c;
  }
</style>
