/**
 * YouTube Transcript Extractor
 * Chrome extension content script để lấy transcript (phụ đề) từ video YouTube
 */

console.log('YouTube Transcript Content Script đã được tiêm vào tab.')

/**
 * Class quản lý việc trích xuất và xử lý YouTube transcript
 */
class YouTubeTranscriptExtractor {
  /**
   * Khởi tạo extractor với ngôn ngữ mặc định
   * @param {string} defaultLang - Mã ngôn ngữ mặc định (ví dụ: 'vi', 'en')
   */
  constructor(defaultLang = 'vi') {
    this.defaultLang = defaultLang
  }

  /**
   * Lấy và phân tích ytInitialPlayerResponse từ trang YouTube
   * @returns {Promise<Object|null>} - Object chứa dữ liệu player hoặc null nếu có lỗi
   */
  async getPlayerResponse() {
    try {
      // Cách 1: Lấy từ trang HTML trực tiếp (nhanh hơn)
      const responseText = await fetch(window.location.href).then((res) =>
        res.text()
      )
      const playerResponseMatch = responseText
        .split('ytInitialPlayerResponse = ')[1]
        ?.split(';var')[0]

      if (playerResponseMatch) {
        return JSON.parse(playerResponseMatch)
      }

      // Cách 2: Tìm trong script tags (backup)
      const scripts = document.querySelectorAll('script')
      const playerResponseScript = Array.from(scripts).find((script) =>
        script.textContent.includes('var ytInitialPlayerResponse = {')
      )

      if (playerResponseScript) {
        const scriptContent = playerResponseScript.textContent
        const jsonStart = scriptContent.indexOf('ytInitialPlayerResponse = {')
        const objectStart = scriptContent.indexOf('{', jsonStart)

        let objectEnd = scriptContent.indexOf(';</script>', objectStart)
        if (objectEnd === -1) {
          const scriptEnd = scriptContent.indexOf('</script>', objectStart)
          objectEnd = scriptContent.lastIndexOf(
            ';',
            scriptEnd !== -1 ? scriptEnd : undefined
          )
        }
        if (objectEnd === -1) {
          objectEnd = scriptContent.lastIndexOf(
            '}',
            scriptContent.indexOf('</script>', objectStart)
          )
          if (objectEnd !== -1) objectEnd += 1
        }

        if (
          objectStart === -1 ||
          objectEnd === -1 ||
          objectEnd <= objectStart
        ) {
          console.error(
            'Could not accurately determine JSON boundaries from script tag.'
          )
          return null
        }

        const jsonString = scriptContent.substring(objectStart, objectEnd)
        return JSON.parse(jsonString)
      }

      // Cách 3: Kiểm tra window object (fallback cuối cùng)
      if (window.ytInitialPlayerResponse) {
        console.log('Found ytInitialPlayerResponse in window object.')
        return window.ytInitialPlayerResponse
      }

      console.error('Failed to obtain playerResponse object.')
      return null
    } catch (error) {
      console.error('Error finding or parsing ytInitialPlayerResponse:', error)
      return null
    }
  }

  /**
   * Tìm và chọn caption track tốt nhất dựa trên ngôn ngữ ưa thích
   * @param {Array} captionTracks - Danh sách các caption tracks có sẵn
   * @param {string} preferredLang - Mã ngôn ngữ ưa thích
   * @returns {Object} - Thông tin về track được chọn và URL của nó
   */
  selectBestCaptionTrack(captionTracks, preferredLang) {
    if (!captionTracks || captionTracks.length === 0) {
      console.log('No caption tracks found.')
      return { baseUrl: null, needsTlang: false, trackInfo: null }
    }

    console.log(`Found ${captionTracks.length} caption tracks.`)

    const findCaptionUrl = (vssIdPrefix) =>
      captionTracks.find((track) => track.vssId?.startsWith(vssIdPrefix))
        ?.baseUrl

    const langVssId = '.' + preferredLang // e.g., ".vi"
    const autoVssId = 'a.' + preferredLang // e.g., "a.vi"

    // Thử tìm theo thứ tự ưu tiên
    let baseUrl = findCaptionUrl(langVssId) // Ưu tiên ngôn ngữ chỉ định (vd: .vi)
    let needsTlang = false

    if (!baseUrl) {
      console.log(
        `No exact match for ${preferredLang} (${langVssId}). Trying fallbacks.`
      )
      baseUrl =
        findCaptionUrl('.') || // Thử bất kỳ ngôn ngữ nào không phải auto-gen
        findCaptionUrl(autoVssId) || // Thử auto-gen của ngôn ngữ chỉ định
        captionTracks[0]?.baseUrl // Lấy track đầu tiên nếu không có gì khác

      // Nếu dùng fallback mà không phải là auto-gen của ngôn ngữ mong muốn, cần thêm tlang
      if (baseUrl && !findCaptionUrl(autoVssId)) {
        needsTlang = true
      }
    }

    // Tìm thông tin về track được chọn để log
    const selectedTrack = baseUrl
      ? captionTracks.find((track) => track.baseUrl === baseUrl)
      : null

    const trackInfo = selectedTrack
      ? {
          name:
            selectedTrack.name?.simpleText ||
            selectedTrack.languageCode ||
            'Unknown',
          isAutoGenerated: selectedTrack.kind === 'asr',
        }
      : null

    return { baseUrl, needsTlang, trackInfo }
  }

  /**
   * Làm sạch text từ transcript
   * @param {string} text - Text cần làm sạch
   * @returns {string} - Text đã làm sạch
   */
  cleanTranscriptText(text) {
    return text
      .replace(/\n/g, ' ') // Thay thế newline
      .replace(/♪|'|"|\.{2,}|\<[\s\S]*?\>|\{[\s\S]*?\}|\[[\s\S]*?\]/g, '') // Loại bỏ ký hiệu nhạc, dấu nháy, v.v.
      .replace(/\s+/g, ' ') // Chuẩn hóa khoảng trắng
      .trim() // Cắt khoảng trắng thừa
  }

  /**
   * Định dạng milliseconds thành chuỗi thời gian MM:SS hoặc HH:MM:SS.
   * @param {number} ms - Thời gian tính bằng milliseconds.
   * @returns {string} - Chuỗi thời gian đã định dạng.
   */
  formatMilliseconds(ms) {
    const totalSeconds = Math.floor(ms / 1000)
    const hours = Math.floor(totalSeconds / 3600)
    const minutes = Math.floor((totalSeconds % 3600) / 60)
    const seconds = totalSeconds % 60

    const paddedSeconds = String(seconds).padStart(2, '0')
    const paddedMinutes = String(minutes).padStart(2, '0')

    if (hours > 0) {
      const paddedHours = String(hours).padStart(2, '0')
      return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`
    } else {
      return `${paddedMinutes}:${paddedSeconds}`
    }
  }

  /**
   * Trích xuất transcript từ dữ liệu JSON
   * @param {Object} transcriptData - Dữ liệu transcript dạng JSON
   * @param {boolean} includeTimestamps - Có bao gồm timestamp không
   * @returns {string|null} - Transcript đã xử lý hoặc null nếu không thành công
   */
  processTranscriptData(transcriptData, includeTimestamps) {
    if (!transcriptData || !transcriptData.events) {
      console.error('Invalid json3 format received or no events found.')
      return null
    }

    if (includeTimestamps) {
      // Xử lý transcript có timestamp
      const transcriptLines = transcriptData.events
        .filter((event) => event.segs && event.tStartMs !== undefined) // Chỉ lấy event có text và thời gian
        .map((event) => {
          const startTime = this.formatMilliseconds(event.tStartMs)
          const text = this.cleanTranscriptText(
            event.segs.map((seg) => seg.utf8).join(' ')
          )

          return text.length > 0 ? `[${startTime}] ${text}` : null
        })
        .filter((line) => line !== null) // Loại bỏ các dòng rỗng

      if (transcriptLines.length === 0) {
        console.log(
          'Transcript events found, but no valid text content could be extracted.'
        )
        return null
      }

      return transcriptLines.join('\n')
    } else {
      // Xử lý transcript không có timestamp
      const fullTranscript = transcriptData.events
        .map((event) => event.segs?.map((seg) => seg.utf8)?.join(' ') || '')
        .join(' ')

      return this.cleanTranscriptText(fullTranscript)
    }
  }

  /**
   * Hàm chính để lấy transcript từ YouTube
   * @param {string} preferredLang - Mã ngôn ngữ ưa thích
   * @param {boolean} includeTimestamps - Có bao gồm timestamp không
   * @returns {Promise<string|null>} - Transcript hoặc null nếu không thành công
   */
  async getTranscript(
    preferredLang = this.defaultLang,
    includeTimestamps = false
  ) {
    const logType = includeTimestamps ? 'timestamped transcript' : 'transcript'
    console.log(`Attempting to get ${logType} for language: ${preferredLang}`)

    try {
      // Bước 1: Lấy playerResponse
      const playerResponse = await this.getPlayerResponse()
      if (!playerResponse) return null

      // Bước 2: Lấy captionTracks
      const captionTracks =
        playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks

      // Bước 3: Chọn caption track tốt nhất
      const { baseUrl, needsTlang, trackInfo } = this.selectBestCaptionTrack(
        captionTracks,
        preferredLang
      )

      if (!baseUrl) {
        console.error('Could not find any suitable caption track baseUrl.')
        return null
      }

      // Log thông tin về track được chọn
      console.log(
        `Selected track: ${trackInfo.name}${
          trackInfo.isAutoGenerated ? ' (auto-generated)' : ''
        }`
      )

      // Bước 4: Tạo URL và fetch transcript
      const transcriptUrl =
        baseUrl + '&fmt=json3' + (needsTlang ? `&tlang=${preferredLang}` : '')
      console.log(`Fetching ${logType} from: ${transcriptUrl}`)

      const response = await fetch(transcriptUrl)
      if (!response.ok) {
        console.error(
          `Failed to fetch transcript json3. Status: ${response.status}`
        )
        return null
      }

      const transcriptData = await response.json()

      // Bước 5: Xử lý và trả về transcript
      const result = this.processTranscriptData(
        transcriptData,
        includeTimestamps
      )

      if (result) {
        console.log(`${logType} extracted and processed successfully.`)
        return result
      }

      return null
    } catch (error) {
      console.error(
        `An unexpected error occurred in getTranscript(withTimestamp=${includeTimestamps}):`,
        error
      )
      return null
    }
  }

  /**
   * Wrapper để lấy transcript không có timestamp
   * @param {string} preferredLang - Mã ngôn ngữ ưa thích
   * @returns {Promise<string|null>} - Transcript hoặc null nếu không thành công
   */
  async getPlainTranscript(preferredLang = this.defaultLang) {
    return this.getTranscript(preferredLang, false)
  }

  /**
   * Wrapper để lấy transcript có timestamp
   * @param {string} preferredLang - Mã ngôn ngữ ưa thích
   * @returns {Promise<string|null>} - Transcript có timestamp hoặc null nếu không thành công
   */
  async getTimestampedTranscript(preferredLang = this.defaultLang) {
    return this.getTranscript(preferredLang, true)
  }
}

// Khởi tạo extractor
const transcriptExtractor = new YouTubeTranscriptExtractor('vi')

// Lắng nghe yêu cầu từ Popup (App.svelte)
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  // Xử lý các yêu cầu từ extension
  const handleRequest = async () => {
    switch (request.action) {
      case 'fetchTranscript':
        console.log('Content script received fetchTranscript request')
        try {
          const transcript = await transcriptExtractor.getPlainTranscript(
            request.lang || 'en'
          )
          if (transcript) {
            console.log('Transcript fetched successfully')
            sendResponse({ success: true, transcript })
          } else {
            console.log('Failed to get transcript, sending error response')
            sendResponse({ success: false, error: 'Failed to get transcript.' })
          }
        } catch (error) {
          console.error('Error handling fetchTranscript message:', error)
          sendResponse({ success: false, error: error.message })
        }
        break

      case 'fetchTranscriptWithTimestamp':
        console.log(
          'Content script received fetchTranscriptWithTimestamp request'
        )
        try {
          const transcript = await transcriptExtractor.getTimestampedTranscript(
            request.lang || 'en'
          )
          if (transcript) {
            console.log('Timestamped transcript fetched successfully')
            sendResponse({ success: true, transcript })
          } else {
            console.log(
              'Failed to get timestamped transcript, sending error response'
            )
            sendResponse({
              success: false,
              error: 'Failed to get timestamped transcript.',
            })
          }
        } catch (error) {
          console.error(
            'Error handling fetchTranscriptWithTimestamp message:',
            error
          )
          sendResponse({ success: false, error: error.message })
        }
        break

      case 'pingYouTubeScript':
        console.log('Content script received ping request, responding.')
        sendResponse({ success: true, message: 'pong' })
        break

      default:
        console.log(`Unknown action: ${request.action}`)
        sendResponse({
          success: false,
          error: `Unknown action: ${request.action}`,
        })
    }
  }

  handleRequest()
  return true // Indicate that sendResponse will be called asynchronously
})

console.log('YouTube Transcript Content Script ready for use.')
